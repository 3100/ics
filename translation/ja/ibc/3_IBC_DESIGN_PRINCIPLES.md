# 3: IBC 設計原則

**これは IBC の「設計原則」についての説明です。**

**IBC 仕様に関する用語の定義は[こちら](./1_IBC_TERMINOLOGY.md)を参照してください。**

**アーキテクチャの概要は[こちら](./2_IBC_ARCHITECTURE.md)を参照してください。**

**ユースケース例については、[こちら](./4_IBC_USECASES.md)を参照してください。**

**デザインパターンの議論については、[こちら](./5_IBC_DESIGN_PATTERNS.md)を参照してください。**

「ブロックチェーン間通信プロトコル」の対象となる設計領域は広く、この用語自体が少し包括的になりすぎています。IBC はその中にあって特定の設計を指すものであり、相互運用可能なブロックチェーンの chain 間エコシステムで想定される特定の汎用性、局所性、モジュール性、効率性を提供する目的で設計されています。このドキュメントでは、IBCの「なぜ」を概説し、主要な上位レベルの設計目標を列挙していきます。

## 汎用性

IBC は*汎用的な*プロトコルになるよう設計されています。それぞれ state machine が異なる言語で異なるセマンティクスを実装した*異種混合の*ブロックチェーンをサポートします。IBC 上で書かれたアプリケーションは一緒に*構成する*ことができ、IBC プロトコルの各ステップは*自動化する*ことができます。

### 異質性（不均一性）

IBC は基本的な要件（高速な finality、一定サイズのstate commitment、簡潔な commitment proof）を持つ任意の consensus アルゴリズムと state machine で実装することができます。プロトコルはデータの認証、転送、順序付けなど、複数 chain アプリケーションの共通要件を処理します — が、アプリケーション自体のセマンティクスには依存しません。IBC で接続される異種混合 chain は互換性のあるアプリケーション層の「インタフェース」（例えばトークン転送用のもの）を理解する必要があります。しかし一度 IBC インタフェース handlerを経由すれば、state machine は（中身が秘密のトランザクションなど）任意の独自機能をサポートすることができます。

### 構成のしやすさ

IBC 上に書かれた複数のアプリケーションは、プロトコル開発者やユーザによって一緒に構成することができます。IBCは認証、転送、順序付けのための基本要素と、アセットやデータセマンティクスのためのアプリケーション層の規格を定義します。互換性のある規格をサポートする chain では、connection を開く（または再利用する）ことを選択した user によって他の chain と接続してやりとりすることができ、アセットやデータは複数の chain 間で自動的に（「マルチホップ」）または手動で（複数のIBC relay トランザクションを順番に送信することで）中継することができます。

### 自動化

IBC における「user」または「actor」 — connection の開始、channel の作成、packet の送信、ビザンチンな不正の報告などを行う — は人間である必要がありません。module、スマートコントラクト、自動化されたオフチェーンプロセスは（例えば計算のためにガスコストを課金する条件で）プロトコルを利用し、独立してまたは協調して動作することができます。複数の chain にまたがる複雑な相互作用（3段階の connection 開始 handshake やマルチホップのトークン転送など）は、最初の初期化以降の動作がユーザーから隠蔽されるように設計されています。最終的には、新しいブロックチェーンを自動的に（物理的なインフラのプロビジョニングは別だが）立ち上げ、IBC connection を開始して、新しい chain の state machine や スループットを完全に自動で利用可能になるかもしれません。

## モジュール性

IBC は*モジュール式*プロトコルになるよう設計されています。プロトコルは明示的なセキュリティ特性と要件を備えた一連の多層コンポーネントとして構築されています。<br>個別の層におけるコンポーネントの実装は（異なる consensus アルゴリズムや connection 開始手順など）様々で、より上位の層に必要な特性（例えば finality、1/3未満のビザンチンに対する安全性、2つの chain 上に組み込まれた信頼できる state といったもの）を提供していれば問題ありません。state machine に必要なのは、安全に相互作用するために IBC プロトコルの互換性あるサブセット（例えばお互いの consensus のための light client 検証アルゴリズム）を理解することだけです。

## 局所性

IBC は*局所的な*プロトコルになるよう設計されています。つまり、双方向 IBC connection のセキュリティと正しさを判断するのに必要なものは、2つの接続された chain に関する情報だけであることを意味します。認証の基本要素についてのセキュリティ要件は、connection に関与するブロックチェーンの consensus アルゴリズムと validator セットのみに頼っています。また IBC connection を維持するブロックチェーンは、接続されている chain の state だけを理解する必要があります（それらの chain が他のどの chain に接続されているかは関係ありません）。

### 通信と情報の局所性

IBC は運用されるブロックチェーンネットワークのトポロジー構造について何の仮定もせず、何の特徴にも依存しません。グローバルなブロックチェーンネットワークのトポロジーを知る必要はありません。安全性と正確性は、2つの chain 間の単一 connection のレベルで判断できます。user や chain は自分たちが知っていて正しいと仮定しているブロックチェーンについてネットワークグラフ構造の一部だけに関する情報を与えられて、自らの仮定やリスクについて（程度の差こそあれ）判断することができます

IBC に「root chain」は必要ではありません。— グローバルネットワークのサブグラフはハブ・スポーク構造に進化するかもしれないし、他のサブグラフは密接なままであるかもしれないし、あるいは変わったトポロジーを採用するかもしれません。channel はエンドツーエンドです。最初のバージョンの IBC ではワンホップ経路のみをサポートしますが、将来的にはマルチホップ経路もサポートする予定です。(ただし consensus アルゴリズムの正しさを前提としているため、自動ルーティングの可能性や安全性が必ずしも高いとは限りません。)

しかし、アプリケーションデータには重要かつ局所的ではない属性が含まれている場合があります。これらはプロトコルの user が注意を払う必要が生じるものです。例えば、複雑なマルチホップ経路で送信されたトークンの送信元ゾーン、クロスチェーン検証を通じてサービスを提供する validator の元のステーク量や個人識別情報、NFT を管理している個別の参照キーが関連付けられた元のスマートコントラクトなどが挙げられます。これらの局所的でない属性は、IBC プロトコル自体が理解できる必要はありませんが、user や上位レベルのアプリケーションによって判断される必要があります。

### 正しさの仮定やセキュリティの局所性

IBC の user — ブロックチェーンレベルや人間あるいはスマートコントラクトレベルで — どの consensus アルゴリズム、state machine、validator セットを「正しいと判断する」（特定の方法で振る舞う、例えば1/3未満のビザンチン）か、そしてどの方法で正しさを判断するか選択します。IBC プロトコルが正しく実装されていると仮定した場合、user はビザンチンな振る舞い、あるいはvalidator セットやブロックチェーンが正しさを明示せずにコミットした不正な state machine 遷移が引き起こすアプリケーションレベルの違反(アセットインフレなど)といったリスクにさらされることはありません。これは大規模な相互接続ブロックチェーンのネットワークトポロジーが想定される場合には特に重要です。そこではブロックチェーンと validator セットが時折ビザンチンであることが想定されるでしょう。 —  IBC は保守的に実装されており、リスクを制限して、起こりうる損害を限定します。

### パーミッションの局所性

connection の確立、channel の作成、packet の送信といった IBC 内の動作は、2つの chain 間の個別の connection に関わる state machine と actor によってローカルに許可されます。個々の chain は、特定のアプリケーション層の動作（委任されたセキュリティ削減など）に対して、パーミッションを司る機構（ガバナンスなど）からの承認を必須にすることもできますが、基本プロトコルでは各動作は許可を必要としません(ガスとストレージのコストを除いて)。もちろん、user は 自身で各 IBC connection の state と consensus を検査し、安全に利用できるかどうかを（例えば、保存されている信頼済みの state に基づいて）判断しなければなりません。

## 効率性

IBC は*効率的*なプロトコルになるように設計されています。chain 間データとアセット中継で償却されるコストの大半は、その下で起こる状態遷移や packet に関連する操作（トークンの転送など）のコストで構成されるべきです。そこには、少量のオーバーヘッドも含まれます。
